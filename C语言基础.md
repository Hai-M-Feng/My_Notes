# C语言基础

## 目录

<!-- TOC tocDepth:2..3 chapterDepth:2..6 -->

<!-- /TOC -->

## 前言

这个教程是写给我朋友看的，大概不会特别严谨，并且非常偏向基础，所以凑合着看吧

## 开发环境

现在写 C 语言常用的有几种 IDE

- **Dev CPP**
  
  - 一个历史比较久远的编译器，安装和操作都很简单
  
  - 缺点在于它太简单了，也就是功能比较简单
  
  - 比较适合初学者使用

- **Visual Studio Code**
  
  - 由微软开发的集成式 **文本编辑器**
  
  - 通过安装各种插件，配置环境，可以让他支持 C 的编译和运行
  
  - 但是非常麻烦，优点是非常灵活，可扩展性强
  
  - 推荐有个性的高手使用

- **Visual Studio**
  
  - 大名鼎鼎的 VS 就是它，我正在使用的 IDE
  
  - 由微软开发的集成开发环境
  
  - 功能强大，不仅支持基础的编译运行，语法高亮
  
  - 还支持实时语法检查，代码补全，高级调试
  
  - 缺点是占用空间和性能比前两个多
  
  - 推荐深入学习的使用

> 安装和创建项目之类的可以自己去查

## 第一个程序

即使你不了解这个程序里面的每个句子是什么意思，但是你也应该把它运行起来

```c
#include <stdio.h>

int main() {
    printf("Hello World!");
    return 0;
}
```

> 这个程序的效果是输出一句 `Hello World!` 

## 数据类型

C 语言是强类型语言，就是说每个变量必须有他的类型，这和数据在内存中的存储方式有关

> 我们都知道电脑只认二进制，比如 `65` 在二进制中是 `1000001`
> 
> 当我们让电脑从内存中拿一段数据时，它拿来了 `1000001`
> 
> 但是这对我们没有用，于是我们需要告诉电脑我们要的是十进制数字
> 
> 现在电脑懂了，拿来 `1000001` 后转换为 `65` 给我们
> 
> 但是我们存储的不只有数字，还有文字，这要怎么办呢？
> 
> 为了应对这种问题，人们最早提出了了 `ASCII` 码
> 
> 它是一个表格，从 `0~127` 位，每个数字对应着一个字符
> 
> 这时候，你告诉电脑你要的是一个字符
> 
> 电脑会先拿来 `1000001` ，转换为 `65` ，再找到 `ASCII` 码的 `65` 位
> 
> 最后把 `A` 给你（ `A` 的 `ASCII` 值是 `65` ）
> 
> 所以，我们在存储数据时，需要明确标的类型

### int 类型

`int` 类型，即整数类型，一般可以表示 $-2147483648 \sim 2147483647$ 

你记得大概是十位数就行

### long long 类型

`long long` 类型，即长整数类型，一般可以表示 $-2^{63} \sim 2^{63} - 1$

你记得大概是十八位就行

### double 类型

`double` 类型，即双精度小数类型，一般实数都能表示

需要注意的是，由于 `double` 使用的是科学计数法

这表示数太大或者精度太高就会丢失精度

### char 类型

`char` 类型，即字符类型，表示 `ASCII` 表范围内的 **单个** 字符

一般只包含转义字符和大小写英文字母以及常用数学符号

### bool 类型

`bool` 类型，即布尔类型，只有 `true` 和 `false` 两种值（真和假）

在逻辑运算中很重要

### 其他的类型

上面只说明了常用的类型，还有一些其他的不常用类型，比如

`float unsigned` 等，我们一般不常用，感兴趣可以自己查

## 变量

变量，可以理解为有类型的存储数据的容器

我们可以重复读取和写入同一个变量

如果你不去操作它，变量的值通常是不变的

我们可以通过下面几种方法来声明一个变量

```c
<变量类型> <变量名>;
```

注意变量名不能是关键字

```c
int a; //单个变量声明
int a, b, c; //多个变量声明
int a = 1; //带初始值的变量声明
int a = b + c; //通过表达式来赋初始值
int a = 0, b = a, c = a * a; //混合使用
char c = 'a'; //字符常量用单引号括起来
double a = 1.0; //养成浮点数即使是整数也带 .0 的习惯
```

## 运算符

运算符是我们常用的对变量的操作方式，分为下面这几种

### 自增运算符

- `i++` 先调用，后自增

- `i--` 先调用，后自减

- `++i` 先自增，后调用

- `--i` 先自减，后调用

> 注意在写程序的时候，无论是自增还是自减，单独拎出来写一句
> 
> 不要在调用的时候自增或自减，会降低程序的可读性

### 算数运算符

- `a + b` `a - b` `a * b` `a / b` `a % b` 数学运算符，注意整数除法会舍去小数位

> `a % b` 即求出 `a / b` 的余数，注意只能整数使用，浮点数需要使用其他函数

### 赋值运算符

- `a = b` 赋值运算符，把 `b` 的值赋给 `a` 

- `a += b` `a -= b` `a *= b` `a -= b` `a %= b` 等同于 `a = a + b` ，以此类推

### 关系运算符

- `==` 等于，注意是两个等号

- `>` `<` 大于，小于

- `>=` `<=` 大于等于，小于等于

- `!=` 不等于

### 逻辑运算符

- `a && b` 逻辑与，左右两边为真返回真，其他返回假

- `a || b` 逻辑或，左右两边有一个为真，返回真，其他返回假

- `!a` 逻辑非，单目运算符，对后面的值取反

### 条件运算符

- `a ? b : c` 唯一的三目运算符，判断表达式 `a` 的值，为真则整个表达式的值为 `b` ，否则为 `c`

> 例如 `(a > b) ? a : b` 是一种很简洁的求最大值的方法

### 指针运算符

- `*` 指针解引用

- `&` 取地址运算符

> 后面会讲，先记着先

## 输入输出

根据经典的 冯·诺依曼 结构的设计，一个完整的计算机程序应该有输入和输出的部分

C 语言提供了多种方法来输入输出

### 输入

#### getchar() 方法

用于接受一个字符类型的数据，可以直接调用，但是经常会出一些奇怪的问题，不推荐使用

除非是用于接受换行等特殊作用

```c
char c = getchar();
```

#### scanf() 方法

用于格式化输入，利用格式控制符，把接收到的每组数据依次写入参数列表中的地址

用于 `Visual Studio` 要求使用安全的输入方法，这里写成 `scanf_s()` 

实际上和 `scanf()` 没什么区别，自己按照习惯使用

```c
scanf_s("%d", &i); //以整数形式读入一个数据写到变量 i 的地址
scanf_s("%d %d", &a, &b); //第一个数赋给 a，第二个赋给 b
scanf_s("%c", &c); //字符型
```

#### 常用格式控制符

- `%d %i` 十进制整数

- `%ld` 长整数，`long long`

- `%o %x` 分别是八进制数和十六进制数

- `%f %lf` 单精度浮点数和双精度浮点数
  
  - 分别对应 `float` 和 `double` ，一般使用 `double`

- `%e` 以科学计数法表示的浮点数

- `%c` 一个字符

- `%s` 一个字符串，需要搭配字符数组使用，后面会讲

#### gets() 方法

用于输入一个字符串，搭配字符数组使用

```c
char s[100];
gets(s);
```

会读取一个字符串直到换行，并依次写进字符数组里面，在末端加上 `\0` 表示字符串结束

### 输出

#### putchar() 方法

用于输出一个字符

```c
putchar('A'); //接受字符常量
putchar(65); //接受整数，自动根据 ASCII 码转换为字符，这里输出 A
char c = 'A';
putchar(c); //接受字符变量
putchar(getchar()); //奇怪的用法
```

在自定义输出的时候很好用

#### printf() 方法

通过格式控制符来输出字符串，会把字符串内的格式控制符依次替换为参数列表中的变量

会自己转换类型，允许使用转义字符

```c
printf("%d\n", 10); //输出 10
printf("%c\n", 65); //输出 A
printf("%d\n", 'A'); //输出 65
printf("%d%d\n", 10, 20); //严格按照格式输出 1020
printf("%d %d\n", 10, 20); //输出 10 20
printf("Hello World! %d\n", 2024); //输出 Hello World! 2024
int a = 10, b = 20;
printf("%d+%d=%d\n", a, b, a + b); //接受表达式，输出 10+20=30
printf("%lf%%\n", 3.14); //两个百分号代表百分号本身，输出 3.14%
printf("%.3lf\n", 3.1415926); //表示输出小数点后3位，四舍五入,输出 3.142
printf("%5d\n", 123); //表示右对齐5位输出整数，输出“  123”，前面两个空格
printf("%-5d\n", 123); //表示左对齐5位输出整数，输出“123  ”，后面两个空格
printf("%10.2lf\n", 3.1415); //右对齐10位，并且只保留两位小数“      3.14”，前面6空格
printf("%05d\n", 123); //右对齐5位输出整数，并且用0填充，输出 00123
```

常用的就这些

#### 转义字符

`ASCII` 码规定的字符，表示特殊的含义，利用反斜杠来使用

- `\n` 换行符，让输出换行（回车）

- `\t` 制表符，`Tab`

- `\'` 表示一个单引号

- `\"` 表示一个双引号

- `\\` 表示一个反斜杠

- `\0` 表示终止字符串

> 其他还有一些不常用的，可以自己去查
> 
> 一些转义字符在不同的编译器下可能会出错，比如 `\b` ，应该避免使用

#### puts() 方法

用于输出一个字符串，直到读取到 `\0` ，并且在最后自动输出一个换行

```c
char c[100] = "Hello World!";
puts(c);
```

## 控制结构

### 选择结构

选择结构用于满足一定条件下执行指定的代码

#### if() 结构

`if` 是最基础的选择结构，用法如下

```c
if (<条件，必须是bool值>) {
    //代码块
}
```

#### if()... else 结构

用来在满足和不满足条件的情况下分别执行不同的代码块

```c
if (<条件>) {
    //代码块
}
else { //不在条件内的情况
    //代码块
}
```

#### else if() 结构

```c
if (<条件一>) {
    //代码块
}
else if (<条件二>) {
    //代码块
}
...
else {
    //代码块
}
```

> 可以看作是 `if` 和 `else` 的连用

#### switch() 结构

```c
switch (<变量>) {
case <值1>: { //<变量> == <值1> 的情况
    //代码块
    break;
}
case <值2>: { //以此类推
    //代码块
    break;
}
default: { //不符合上面的所有情况，默认的代码，可以省略
    //代码块
    break;
}
}
```

> 可以看作是简化版的 `if()... else` 连用

### 循环结构

循环结构一般用来处理需要重复操作的步骤，需要牢牢掌握

#### while() 结构

基本结构为

```c
while (<循环条件 bool值>) {...}
```

当循环条件为真时，程序会一直循环 `...` 里面的代码，直到循环条件变为假

写的时候一定记得写退出条件，否则会死循环

**一般形式**

```c
while (<循环条件>) {
    //....
}
```

**特殊写法** 适用于不在开头判断条件的情况

```c
while (true) {
    //...
    if (<退出条件>) {
        break;
    }
    //---
}
```

**小技巧** 在调用 `bool` 值时，如果传入的值为 `0` ，则为假（字符的 `\0` 也可以）

```c
int i = 100;
while (i--) {
    //...
}
```

#### do... while() 结构

和 `while()` 没什么区别，只是把条件判断放到执行代码后面

基本形式为

```c
do {...} while (<循环条件>); //别忘了后面有个分号
```

一般还是建议用 `while ()`

#### for() 结构

最常用的循环结构，非常好用

基本形式

```c
for (<初始化表达式>; <条件表达式 bool值>; <迭代表达式>) {
    <代码块>
}
```

`for` 循环的结构中包含四个部分

- 初始化表达式：
  
  - 在开始循环的时候执行一次，一般用于声明循环变量

- 条件表达式：
  
  - 每次循环前判断一次，值为真继续循环，为假退出循环

- 迭代表达式：
  
  - 每次循环末尾执行一次，一般用于迭代循环变量

- 代码块：
  
  - 循环的代码

需要注意的是表达式之间使用分号隔开

常见的 `for` 循环形式

```c
for (int i = 0; i < n; i++) { //可以在这里面声明临时变量
    //...
}
```

#### continue 和 break

在循环中可以使用 `continue` 和 `break` 来调整循环

- `continue` 可以让程序直接进入下一次循环，跳过它之后的代码

- `break` 可以直接结束整个循环，开始执行循环之后的语句

## 函数

函数是 C 语言中的重要组成部分

C 语言中函数分为两大类，分别是 **标准库函数** 和 **用户定义函数**

标准库函数就是 C 语言自定义的函数，比如 `scanf() printf()` 等

这里讲的是用户定义函数

#### 声明函数

函数也是需要声明的，基本方式如下

```c
<函数类型> <函数名>(<参数列表>) {
    <函数体>
}
//比如
void prtHelloWorld() {
    printf("Hello World!");
}
```

##### 函数类型

首先要讲的是函数类型，函数的类型和它返回的值的类型挂钩

上面的例子不需要返回值，所以用 `void` ，下面是一个有返回值的例子

```c
double getPI() {
    return 3.14159265358979;
}
```

函数的类型必须和返回值的类型相同

##### 传参

我们有时需要传入一些值，这个过程叫做传参

- 在声明函数时声明的参数叫做 **形式参数**

- 在调用函数时传入的值有实际的数据，叫做 **实际参数**

声明形式参数时，括号内的叫做参数列表

参数之间使用逗号隔开，调用函数的时候也是这样

```c
void put_a_char(char c) { //只有一个参数
    putchar(c);
}

int add(int a, int b) { //两个参数
    return a + b;
}

int adds(int a, int b, int c, int d) { //多个参数
    return a + b + c + d;
}
```

我们可以注意到，参数列表中的形参是有类型的

在调用函数的时候，实参必须对应形参的类型和数量

有时候我们在操作参数时希望不只是使用复制过来的数，而是直接操作实参本身

比如说把两个数的值交换，按照上面的方法是没办法对原来的数操作的

因为形参实际上是实参的拷贝

使用下面这种方法可以操作实参本身

> 可以看完指针再看这部分

```c
void swap(int* i) {} //就是指针的传递
```

```c
#include <stdio.h>

void swap(int* n1, int* n2) {
    int temp = *n1;
    *n1 = *n2;
    *n2 = temp;
}

int main() {
    int a = 1, b = 2;
    printf("%d %d\n", a, b);
    swap(&a, &b);
    printf("%d %d\n", a, b); //可以看到 a,b 的值交换了
    return 0;
}
```

> 这种方法叫做 **引用调用** ，之前的方式叫做 **传值调用**

> 数组传递可以看完数组再来看

有时我们需要传递一个数组，可以用下面这种方法

```c
void example(int a[]) { //写一个没有长度的数组
    //...
}
```

**这是一个例子** 仿写了 `puts` 函数，

```c
#include <stdio.h>

void fake_puts(char c[]) {
    int i = 0;
    while (true) {
        if (c[i] == 0)
            break;
        else {
            putchar(c[i]);
            i++;
        }
    }
}

int main() {
    char cr[10] = "Hello!";
    fake_puts(cr);
    return 0;
}
```

注意传递的实参是数组名

#### 参数操作

在函数当中，我们操作的都是形式参数

> 引用调用虽然相当于是直接操作实参，但是仍然是使用形参的名字

可以理解为函数当中只能使用形参

当我们调用函数的时候，实际上有一个赋值的过程

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int c = 1, d = 2;
    add(c, d);
    return 0;
}
```

比如上面这个例子，在调用 `add` 的时候，实际上有个

```c
int a = c;
int b = d;
```

的过程

所以我们在函数中操作的实际上是实参的拷贝

#### 返回值

正如上面的例子，我们在写一些函数的时候，经常会返回一些值

这个时候可以使用 `return` 关键字

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int c = 1, d = 2;
    int e = add(c, d);
    return 0;
}
```

在这个例子里面

```c
int e = add(c, d);
```

这一句的意思是调用这个函数的值对 `e` 赋值

首先编译器会检查，`add` 类型和 `e` 的类型是否一致

一致的话，程序会调用 `add` 函数运算

`add` 函数最后返回了 `a + b` 的值

这时候程序就会拿 `a + b` 的值给 `e` 赋值

这就是函数类型和返回值必须保持一致性的原因

#### 调用函数

写了函数一定要用的嘛，使用的方式也很简单

```c
<函数名>(<实参列表>)
```

之前也应该见过了

这里着重说明一个原则：函数的调用必须在声明之后

比如说下面这段代码

```c
int main() {
    int c = 1, d = 2;
    int e = add(c, d);
    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

运行的时候是会报错的，因为调用 `add` 在 `int add` 之前

解决这个问题有两种方法

首先是直接把整个方法提前

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int c = 1, d = 2;
    int e = add(c, d);
    return 0;
}
```

优点是写起来简便

但是有时候写一些大型项目，函数非常多，会把 `main` 函数挤到最底下，让程序难以阅读

这时候应该把函数的声明和实现分开

```c
int add(int a, int b);

int main() {
    int c = 1, d = 2;
    int e = add(c, d);
    return 0;
}

int add(int a, int b) {
    return a + b;
}
```

实际上就是把前半截放到调用之前，用分号结尾，再在后面找个地方写函数就行了

需要注意的是，函数中不能声明函数

#### 函数嵌套和递归调用

函数是可以调用其他函数的

这种调用方式叫做函数嵌套

```c
int add(int a, int b) {
    return a + b;
}

int adds(int a, int b, int c) {
    return add(a, add(b, c));
}

int main() {
    int c = 1, d = 2, e =3;
    adds(c, d, e);
    return 0;
}
```

可以看到，`adds` 函数中嵌套调用了两次 `add` 

同样的，函数也可以调用它本身

这种方式叫做递归调用

写递归调用的时候一定要记得写返回条件，这个条件叫做递归边界

比如下面这个倒叙输出数字的函数，使用了递归调用

```c
void printReverse(int num) {
    if (num < 10) { // 基本情况：如果数字是一位数，直接输出
        printf("%d", num);
    } else {
        printf("%d", num % 10); // 输出最后一位
        printReverse(num / 10); // 对剩下的部分继续调用函数
    }
}
```

> `n < 10` 是递归边界

需要注意的是：递归调用会大大降低程序的可读性，还有爆栈的风险，非必要不要使用递归

## 数组

数组就是一组数的集合，我们可以通过下标来访问一个数组中的每个元素

使用数组可以处理大量的数据，或者对一些数据进行系统管理

### 声明数组

声明数组的方法很简单

```c
<数组类型> <数组名>[<数组成员数>];
//比如
int numbers[10];
```

注意数组成员数必须是常量（确定值），不能是变量

想使用变量来声明数组长度需要学习动态内存分配，这里先不讲

还有需要注意的是，数组的下标从 `0` 开始

对于上面这个数组，你能访问的是 `numbers[0] ~ numbers[9]`

### 数组的初始化

可以使用参数列表对数组初始化

```c
int numbers[10] = {1, 2, 3, 5, 8};
```

上面这个语句声明了 `numbers` 数组，并且对前五项分别进行了赋值

> 对于字符串数组有其他的初始化方法，在字符串章节会讲

需要注意的是，对于没有初始化的元素，如果你直接调用它，输出的通常是乱码

有的时候我们不用赋初始值，只需要初始化为 `0` 直接写循环挨个赋值比较麻烦，可以

```c
int n[100];
memset(n, 0, sizeof(n)); //需要包含 string.h
```

上面这句 `memset` 的作用是，从 `n` 这个地址开始，填充 `0` ，长度为 `n` 的长度

> 这里补充一个知识点，数组名代表的是数组的起始地址，加上[]才是数组的元素

### 数组的访问

通过数组名加 `[]` 可以访问数组中的某个元素

对于一个长度为 `n` 的数组，你能访问的是 `0 ~ n - 1` 

如果访问了超出数组范围的元素，会报错，这种行为叫做越界访问

### 二维或多维数组

有时我们需要存储一个矩阵之类的数据，一维数组显然不是很够用

这时候我们可以声明二维数组或者多维数组

```c
<数据类型> <数组名>[<元素个数>][<元素个数>];
//例如
int numbers[10][20];
```

对于理解多维数组的概念，这里有两种方法

#### 空间想象法

比较好理解，一维数组就是一条线，只有 x 轴，相当于访问坐标是 (x) 的元素

二维数组就是一个面，有 x,y 轴，访问的是位于 (x, y) 的元素

三维就是加个 z 轴

但是三维以上就不好想象了，这里推荐另一种方法

#### 索引法

想像一个你数组名命名文件夹，里面有一些文件，按照 `0 ~ n - 1` 编号

你调用时就是调用了这个文件夹里面的某个文件

二维数组就是在大的文件夹里面，按照建了小文件夹，每个文件夹里面按照编号放着文件

比如

```c
int numbers[10][5];
int i = numbers[7][2];
```

就是建了个叫 `numbers` 的文件夹，里面有十个小文件夹，每个小文件夹里面有五个文件

第二句就是我们找到 `numbers` 里面的七号文件夹里面的二号文件取出来

三维数组就是再分小文件夹

> 总之理解方法因人而异，自己理解了才是最重要的

### 其他

我想不出来数组还有什么好讲的了

其他的都是一些操作方法，这些都得在情景下讲，遇到问题直接问吧

## 字符串

由于 C 语言里面没有 `string` 类型

在说到 C 语言的字符串的时候，一般指的是字符数组 

### 声明和初始化一个字符数组

按照数组的方法即可

```c
char str1[1000]; //后面的是字符串的长度
```

初始化则可以直接使用字符串常量

```c
char str1[1000] = "";
char str2[1000] = "Hello World!";
```

如果使用字符串常量初始化，可以不指定长度，但是会导致字符串不能扩展

```c
char str1[] = "Hello World!";
```

如果你比较闲，也可以这样写

```c
char str1[1000] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

这里介绍字符串的重要性质

字符串的末尾一定是 `\0` ，用来表示结束字符串

在我们使用字符串常量赋值时，系统自动在末尾加上了 `\0` 

### 字符串的输入和输出

- `scanf` 方法
  
  - ```c
    char str[1000];
    scanf("%s", str);
    ```
  
  - 之前讲过，`scanf` 的参数是变量地址
  
  - 同时，数组名代表数组的起始地址
  
  - 所以在输入字符串的时候，只需要输入字符数组名就行
  
  - 注意这种方法在遇到空格时会停止输入
  
  - 还需要注意的是，由于 VS 需要使用安全方法，要指定缓冲区的大小
  
  - ```c
    char str[1000];
    scanf_s("%s", str, 999); //最多输入999个字符
    ```

- `gets` 方法
  
  - ```c
    char str[1000];
    gets(str);
    ```
  
  - 这种方法的优势在于写起来很简单，会读入空格或者制表符，在换行时结束读取
  
  - 在使用 VS 时需要改成 `get_s` ，使用方法不变

- `fgets` 方法
  
  - ```c
    char str[1000];
    fgets(str, sizeof(str), stdin);
    ```
  
  - 推荐的方法，相较于 `gets` 更加安全，保证了输入不会越界
  
  - `stdin` 标准输入流，照抄就行
  
  - VS 可以正常使用

- `printf` 方法
  
  - 后面的是输出方法
  
  - ```c
    char str[100] = "Hello";
    printf("%s", str);
    ```
  
  - 其实输出方法都差不多，随便记一个就行了

- `puts` 方法
  
  - ```c
    char str[100] = "Hello";
    puts(str);
    ```

### 字符串操作

`string.h` 中包含了许多有用的字符串操作方法

#### strlen() 方法

输入一个字符串，返回字符串的长度（不包括 `\0`）

```c
char str[] = "Hello";
int length = strlen(str);
```

#### strcpy() 方法

用于复制字符串

```c
char str1[] = "Hello";
char str2[100];
strcpy(str2, str1);
//把后面的字符串赋值给前面的字符串
```

需要注意的是，接受复制的字符串长度必须大于原字符串

这里提供一种动态分配内存来复制的方法，这种方法可以动态分配 `str2` 的大小

```c
//需要包含 string.h 和 stdlib.h（用于内存操作）
char str1[] = "Hello!";
char* str2 = (char*)malloc(strlen(str1) + 1); //通过str1的长度动态分配str2长度
strcpy_s(str2, strlen(str1) + 1, str1); //VS的安全复制方法中间的是字符串长度
puts(str2); //输出
free(str2); //释放内存，没有这一步会导致内存泄露
```

需要注意的是这种方法的变量在堆上而不是在栈上，需要手动释放内存

#### strcat() 方法

把 `str2` 接在 `str1` 后面

```c
char str1[1000] = "Hello";
char str2[] = " World!";
strcat(str1, str2);
```

在 VS 中，你需要使用安全的方法

```c
char str1[1000] = "Hello";
char str2[] = " World!";
strcat_s(str1, sizeof(str1), str2); //中间的是str1长度
puts(str1);
```

同样提供一种动态分配内存的方法

```c
char str1[] = "Hello";
char str2[] = " World!";
char* str3 = (char*)malloc(sizeof(str1) + sizeof(str2) + 1); //str3长度是前两个之和
strcpy_s(str3, sizeof(str1) + 1, str1); //先把str1复制到str3
strcat_s(str3, sizeof(str1) + sizeof(str2) + 1, str2); //然后把str2复制到str3后面
puts(str3);
free(str3); //别忘了释放内存
```

实际使用中，还是直接写个 `char str[1000]` 得了，肯定够用

#### 其他方法

`string.h` 中还有许多方法，感兴趣可以自己去查

## 指针

指针是 C 语言以及 C++ 中的一种工具，一般只在低级语言中使用

它很强大，能让我们直接访问内存，上面的例子中有使用

但是它同样危险，所以高级语言都放弃了指针，使用其他安全的方法

注意这是一种危险的行为，直接访问内存可能导致

1. **内存泄漏 (Memory Leaks)**

当程序分配了内存但未能正确释放时，就会发生内存泄漏。随着时间的推移，未释放的内存会累积，最终导致程序占用过多内存，影响性能甚至导致程序崩溃。

2. **缓冲区溢出 (Buffer Overflow)**

缓冲区溢出是指向内存缓冲区写入超出其边界的数据。这可能导致覆盖相邻内存区域的数据，引发不可预测的行为，甚至可能被恶意利用来执行任意代码。

3. **非法内存访问**

直接访问内存时，如果不小心访问了无效或受保护的内存区域，可能会导致程序崩溃或系统不稳定。例如，尝试读取或写入一个已经释放的指针指向的内存区域。

4. **数据损坏**

如果多个指针指向同一块内存区域，并且其中一个指针错误地修改了数据，那么所有依赖该数据的其他部分都会受到影响，导致数据不一致或损坏。

5. **安全漏洞**

直接访问内存增加了安全风险，特别是缓冲区溢出等漏洞可以被攻击者利用，注入恶意代码或提升权限。

6. **并发问题**

在多线程或多进程环境中，如果多个线程或进程同时访问同一块内存区域，而没有适当的同步机制，可能会导致竞态条件（race conditions），从而引发数据不一致或其他问题。

7. **调试难度增加**

由于直接内存访问的复杂性和潜在的副作用，调试相关问题通常比调试高级语言中的问题更加困难。错误可能难以复现和定位。

8. **程序的可移植性降低**

直接内存访问往往依赖于特定平台的内存布局和行为，这使得程序在不同平台上的移植变得更加困难。

> 我已经提醒了你使用指针可能对电脑造成的危害，下面是教学

### * 和 &

指针操作中会运用到两种操作符，分别是 `*` 和 `&`

- `*` ，叫做解引用操作符，用来访问指针实际指向的数据
  
  - 在声明指针时表示这是一个指针

- `&` ，叫做取地址操作符，返回它后面的变量的地址

### 声明一个指针

指针也具有类型，需要和它访问的数据类型相同，举例都使用 `int` 类型

```c
int *p;
//或者
int* p;
```

这两种方法的意思是一样的，区别在于强调的不同

- `int *p` 着重强调的是一个 `int` 类型的指针 `*p` ，`*p` 作为一个整体

- `int* p` 着重强调 `p` 是一个 `int*` 整数指针，把指针和类型作为一个整体

> 这两种类型的使用取决于个人和团队的喜好，我更喜欢使用 `int* p`
> 
> 需要注意的是，`int* p, q;` 实际上是声明了一个指针 `p` 和一个变量 `q` 
> 
> 需要写成 `int* p; int* q;`
> 
> 使用传统写法则是 `int *p, *q;`

### 初始化指针

我们都知道，指针指向的是一个地址

所以指针存储的数据的应该是地址，而不是实际上的某种类型的变量

因此，我们赋给指针的值应该是一个地址

这时候需要用到 `&`

```c
int a = 10; //一个变量
int* p; //声明了一个指针
p = &a; //把a的地址赋给了指针
printf("%p\n%p", &a, p); //分别输出了a的地址以及p储存的地址
```

我们可以看到，`a` 的地址和 `p` 储存的地址相同，所以 `p` 可以根据地址访问 `a`

### 通过指针访问数据

指针存储的是地址，那我们应该如何使用指针访问数据呢？

这时候需要用到 `*` 

```c
int a = 10; //一个变量
int* p; //声明了一个指针
p = &a; //把a的地址赋给了指针
printf("%d", *p); //将p解引用
```

这里 `*p` 可以理解为，通过 `p` 的类型，直接把 `*p` 指向的地址的数据当作变量用

所以我们也可以直接通过指针改变 `a` 的值

```c
int a = 10; //一个变量
int* p; //声明了一个指针
p = &a; //把a的地址赋给了指针
*p = 20; //通过指针改变a的值
printf("%d", a); //输出a的值
```

可以看到，`a` 的值以及变成了 `20` 

### 指针与数组

通过指针可以访问数组的值

```c
int a[5] = { 1, 2, 3, 4, 5 };
int* p = a;
printf("%p\n%p", &a[0], p);
```

首先，我们声明了一个数组

然后把数组的首地址赋给了指针（之前说过数组名代表数组首地址，其实也是个指针）

然后输出了数组的第一项的地址和指针存储的地址

可以发现他们是一样的

**然后我们需要了解指针位移（指针算术运算）**

数组在内存中是连续的，我们可以通过算数运算移动指针的位置

```c
int a[5] = {1, 2, 3, 4, 5};
int* p = a;
for(int i = 0; i < 5; i++) {
    printf("%d ", *p);
    p++;
}
```

这里可以看到，我们每次让 `p++` 时，指针往后移动了一个元素

实际上在内存中移动了 `sizeof(int)` 的长度

因为数组在内存中是连续的，所以每后移一个单位指针就指向了下一个数组元素

> 需要注意的是上面这段程序有个问题
> 
> 指针在访问完最后一个变量时，仍然进行了自增
> 
> 这个时候指向了一个没有被声明的地址，继续访问会导致未定义行为
> 
> 这种指针被称为 **野指针**
> 
> 在实际应用中切忌出现野指针

既然可以通过自增来移动，也可以通过加法来移动

```c
int a[5] = {1, 2, 3, 4, 5};
int* p = a;
for(int i = 0; i < 5; i++) {
    printf("%d ", *(p + i));
}
```

这里是让指针每次加上了 `i` 

实际上在内存中是后移了 `sizeof(int) * i` 的长度

所以能访问第 `i` 个元素

注意这里是让指针先移动到 `p + i`

再解引用 `*(p + i)` 访问 `a[i]`

如果写成 `*p + i` 的话，实际上是会把 `a[0]` 的值与 `i` 的值相加

> 我们在使用 `a[i]` 时，访问原理其实就是 `*(a + i)` ，数组名本身是一个指针

### 指针与多维数组

我们同样可以通过指针来访问多维数组

首先我们应该了解多维数组在内存中的存储方式

由于内存的存储是连续的，所以多维数组其实是以一维数组的方式存储，例如

```c
int a[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
};
```

在内存中的存储方式实际上是

```c
a[0][0] a[0][1] a[0][2] a[0][3]
a[1][0] a[1][1] a[1][2] a[1][3]
a[2][0] a[2][1] a[2][2] a[2][3]
//内存中
a[0][0] a[0][1] a[0][2] a[0][3] a[1][0] a[1][1] a[1][2] a[1][3] a[2][0] a[2][1] a[2][2] a[2][3]
```

内存中以行优先的规则来存储多维数组

所以我们可以通过这种方式来访问多维数组的元素

```c
int a[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
};
int* p = &a[0][0];
for (int i = 0; i < 3; i++) {
    //读取列索引为 1 的元素
    printf("%d\n", *(p + 1 + 4 * i));
}
```

上面把 `a` 的首地址 `&a[0][0]` 给了 `p` 

`*(p + 1 + 4 * i)` 这一句的意思是先把 `p` 移动到索引为 `1` 的列

每次再移动 `4 * i` 就是一行的长度，从而做到列的读取

> 这种方式一般用在操作堆上面的内存中的自定义格式数组（需要手动分配和释放）
> 
> 操作栈上的内存（就是普通的数组）一般用下面的方法

这里我们会发现一个问题，就是不能直接把 `a` 直接赋值给指针

这是因为在二维数组中，数组名实际上是一个指针数组

### 数组指针

```c
int a[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
};
```

在这个数组中，我们直接查看 `a` 的类型，可以发现是 `int (*)[4]`

这表示 `a` 是一个指向有四个元素的数组的指针，即数组指针

实际上 `a` 指向的是 `a[0]`

我们按照这种方式把 `a` 的地址赋给指针

```c
int (*p)[4] = a;
```

这时候，指针 `p` 指向的内容是

```c
p -> a[0]
```

而 `a[0]` 是一个包含四个元素的一维数组

当我们使用 `p[i]` 的时候，实际上是在指针 `p` 上加上 `i` 个包含4个 `int` 类型元素的数组的长度 `*(p + i)`

之所以是4，是因为 `int (*p)[4]` 中指针指向的是一个有四个元素的数组

`p + i` 的地址偏移是 `i * 16` 字节（即 `i * 4 * sizeof(int)`）

所以 `p[i]` 指向的是

```c
p[0] -> a[0][0] a[0][1] a[0][2] a[0][3]
p[1] -> a[1][0] a[1][1] a[1][2] a[1][3]
p[2] -> a[2][0] a[2][1] a[2][2] a[2][3]
```

于是我们可以通过这种方法访问数组中的每个元素

```c
//访问 p[1][2]
        a[0][0] a[0][1] a[0][2] a[0][3]
p[1] -> a[1][0] a[1][1] a[1][2] a[1][3]
                        ^
                        p[1][2]
```

当我们在使用 `p[i][j]` 时，实际上指针偏移了

```c
*((int *)p[i] + j)
//或者
*(*(p + i) + j)
```

也就是从 `p[i]` 往后偏移了 `j * sizeof(int)` 的长度

我们可以通过这种方法访问数组中的某个元素

```c
int a[3][4] = {
    {1, 2, 3, 4},
    { 5, 6, 7, 8 },
    { 9, 10, 11, 12 },
 };
int (*p)[4] = a;
for (int i = 0; i < 3; i++) {
    //读取列索引为 1 的元素
    printf("%d\n", p[i][1]);
}
```

需要注意的是，索引运算符 `[]` 已经包含了解引用，不需要写 `*` （写了其实也没问题）

> 无论懂没懂，照这么写就对了

### 指针数组

我们在刚刚看到了这种写法

```c
int (*p)[4]; //数组指针
```

它和这种写法很像

```c
int* p[4]; //指针数组
```

其实它们完全不一样

- 数组指针实际上只有一个指针，它指向一个数组

- 指针数组是多个指针的集合，你可以直接按照使用数组的方法使用每个指针

### 指针和字符串

字符串作为一个字符数组，同样可以使用指针访问

这里就仿写一个 `puts` 函数，同时使用指针传参

```c
void fake_puts(char* c) {
    while (*c != '\0')
        putchar(*(c++));
}
```

可以看到，和我们之前传递数组的方式相比，这种方式更加简洁

把字符数组当作普通数组操作就行，没什么好讲的

### 其他

你可能想问，这些指针的操作，我用普通的操作数组的方法也能做到啊？

实际上这些只是指针的基础操作

指针真正发光发热的地方是在内存管理，内存操作的部分

## 结构体和联合体

结构体和联合体是类的早期概念

它们能包含成员，但是不能包含方法，在进行多种数据的整体操作时很有用

### 定义一个结构体

我们需要使用 `struct` 关键字，在全局作用域写（就是函数外边）

```c
struct <结构体名> {
    <结构体成员>
};
//例如
struct student {
    int age = 18;
    int grade;
    char name[100];
};
```

从上面的例子可以看出，一个结构体中可以包含多种不同的类型的成员

也可以包含数组，赋初始值

### 声明一个结构体变量

我们定义了结构体以后，并不是对结构体本身操作，而是声明一个结构体变量操作

```c
//假设我们已经定义了student结构体
struct student s1;
```

这句的意思是，声明一个叫做 `s1` 的 `student` 类型的结构体变量

在 VS 等 `GCC` 编译器中，你也可以按照类似类的方式声明结构体变量

```c
student s1;
```

> 但是最好还是按照标准方式加上 `struct`

### 操作一个结构体变量

首先，可以使用 `.` (成员访问运算符)对结构体变量操作

注意是对变量操作，而不是结构体本身

访问成员变量以后按照普通变量用就完了

```c
struct student s1;
s1.age = 18;
s1.grade = 1;
strcpy_s(s1.name, 100, "HaiMFeng");
printf("%s %d", s1.name, s1.age);
```

> 对字符串操作需要按照字符串的方式

### 结构体指针

我们也可以通过结构体指针访问结构体

指针怎么来就怎么来

需要注意的是 `.` 需要改成 `->` （也叫成员访问运算符，但是指针专用）

`->` 实际上是 `.` 和 `*` 的结合

```c
ptr->name;
//等价于
(*ptr).name;
```

下面是一个使用结构体指针的例子

```c
struct student s1;
struct student* p = &s1;
p->age = 18;
p->grade = 1;
strcpy_s(p->name, 100, "HaiMFeng");
printf("%s", s1.name);
```

### 结构体数组

按照数组的方式来就行，下面是一个简单的例子

```c
struct student ss[2];
ss[0].age = 18;
ss[1].age = 19;
printf("%d %d", ss[0].age, ss[1].age);
```

同样的可以开多维数组

### 结构体嵌套

同样的，结构体里面也可以塞结构体，例如

```c
struct University {
    char name[100];
    char address[100];
};

struct student {
    int age = 10;
    int grade;
    char name[100];
    struct University school;
};

int main() {
    struct student s1;
    strcpy_s(s1.school.name, 100, "合肥工业大学");
    printf("%s", s1.school.name);
    return 0;
}
```

我们分级调用子结构体的成员即可

需要注意的是，和函数类似，结构体的调用一定要在定义之后

如果我把 `University` 结构体的定义放到 `student` 结构体的定义下面

编译器就会报错，因为 `student` 的定义中调用了 `University` 结构体

### 联合体

联合体和结构体类似，不过泛用性就是依托答辩

我们同样可以在联合体里面加入成员，对其操作

区别在于，联合体中所有成员共用同一块内存

意思就是，当你对联合体中的一个 `成员1` 赋值，再对 `成员2` 赋值

这时候，`成员1` 的值已经消失了，因为被 `成员2` 覆盖掉了

> 它相比结构体的唯一优势占用的内存取决于最大的成员
> 
> 而结构体占用的内存是所有成员的总和

这里只给出一个例子

```c
union point {
    int x;
    int y;
};

int main() {
    union point p;
    p.x = 10;
    printf("x = %d\n", p.x);
    p.y = 20;
    printf("y = %d\n", p.y);
    printf("x = %d\n", p.x);
    return 0;
}
```

> 输出的结果是
> 
> x = 10
> 
> y = 20
> 
> x = 20

可以看到，第二次调用 `x` 的时候，他已经被 `y` 覆写了

我之所以还能访问 `x` 是因为 `x, y` 类型相同

当不同类型成员的数据覆写了内存的话，不要尝试使用原类型成员读取

这会导致未定义行为

**总之别用联合体**

## 枚举类型

枚举类型实际上就是整合的被命名的整型变量

通过将一些有固定范围的值的命名整合，从而提高程序可读性

> 上面的是官方的说法，实际上我觉得枚举类型的可读性是一坨，基本上没有使用过

### 定义一个枚举类型

我们可以通过下面的方法定义一个枚举类型

```c
enum Weekday {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
};
```

这个例子通过枚举类型声明了一个 `Weekday` ，包含周一到周日

需要知道的是，枚举类型会隐式地赋值

上面的例子中，`MONDAY` 的值默认为 `0`

后面的依次递增，到 `SUNDAY` 为 `6`

我们可以通过下面的方法来验证

```c
enum Weekday today = THURSDAY;
printf("%d", today);
```

> 输出的值为 3

我们可以显式地对成员赋值

```c
enum Weekday {
    MONDAY = 1,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
};
```

现在他们的值为 `1 ~ 7` 了

### 声明一个枚举变量

上面已经出现过了

```c
enum <枚举类型> <变量名>;
```

同时可以赋初始值，声明数组之类的

### 操作枚举变量

我们可以对枚举类型进行下面的操作

```c
enum Weekday today, tomorrow;
today = THURSDAY; //直接赋值
tomorrow = today; //变量赋值
today = (enum Weekday)4; //强制类型转换
tomorrow = (enum Weekday)((today + 1) % 7); //算数运算后类型转换
```

> 总之，我觉得枚举类型这东西不是很好用，用不用看个人喜好和书写习惯

## 文件操作

我们有时需要把程序运行的结果保存到本地

或者是读取本地文件进行操作

这时候需要用到文件操作

### 打开文件

在 C 语言当中，打开文件的操作会获得一个文件指针

```c
FILE* readptr = fopen("in.txt", "r");
FILE* writeptr = fopen("out.txt", "w");

if (readptr == NULL) {
    printf("File opening failed");
    return -1;
}
if (writeptr == NULL) {
    printf("File opening failed");
    return -1;
}
```

首先，指针是 `FILE` 类型的（必须全大写）

然后通过 `fopen` 打开文件并且返回文件指针

`fopen` 里面的两个参数分别是文件名和读写方式

- `"r"` 代表仅读取（read）

- `"w"` 代表仅写入（write）清空或创建文件，再写入

- `"a"` 追加写入（add）不删除原有内容，在文件末尾添加

然后我们需要判断文件是否正常打开，即判断指针是否为空

> 虽然 "w+" "r+" "a+" 的方法可以同时读写文件，但是通常我们把输入和

### 操作文件

读写文件有几种方法，这里提供比较方便的 `fprintf` `fscanf` ，其他的感兴趣可以去查

```c
//假设我们已经按照上面的方法打开了文件
int a;
fscanf(readptr, "%d", &a);
fprintf(writeptr, "%d", a);
```

可以看到，用法和普通的 `scanf` `printf` 差不多，就是在最前面加了个文件指针参数

> VS 要求使用安全的 `fscanf_s` 方法，其实就是 `scanf_s` 加个文件指针

### 关闭文件

在我们操作完文件以后需要将其关闭，否则会一直占用文件

关闭文件很简单，使用 `fclose()` 就行了

需要注意的是要重置指针，防止指针空挂

```c
fclose(readptr);
fclose(writeptr);
readptr = nullptr;
writeptr = nullptr;
```

正常的文件操作流程就是这样

下面是一个完整的文件操作流程的例子

> 由于 VS 要求使用安全的方法，我懒得改，所以我没有实际跑过
> 
> 但是逻辑应该是正确的

```c
FILE* readptr = fopen("in.txt", "r");
FILE* writeptr = fopen("out.txt", "w");

if (readptr == NULL) {
    printf("File opening failed");
    return -1;
}
if (writeptr == NULL) {
    printf("File opening failed");
    return -1;
}

//假设我们已经按照上面的方法打开了文件
int a;
fscanf(readptr, "%d", &a);
fprintf(writeptr, "%d", a);

fclose(readptr);
fclose(writeptr);
readptr = nullptr;
writeptr = nullptr;
```

## 内存管理

在我们声明数组的时候，如果你开了这样一个数组

```c
int a[1000000];
```

那么程序可能会报错，甚至崩溃

这种情况用通俗的语言来说就是 “爆栈”（栈溢出） 了

这种问题涉及内存的管理方式

### 堆 和 栈

内存当中有两种管理的方式

**栈（Stack）** 

在 C 语言中，程序会自动管理一部分内存，这部分叫栈

当我们在程序当中声明数组，调用函数时，程序会自动分配相应的空间

当程序结束时，会自动销毁栈中的数据

但是栈的大小通常比较小，就像上面的，开个一百万大小的数据就爆了

对于大型数据或者需要动态分配内存的情况，我们会在堆上操作

**堆（Heap）**

堆实际上就是一块动态内存空间，特点是空间大，存储灵活

但是堆的空间需要我们手动申请和释放

这一章节讲的就是对堆空间的操作

> ---
> 
> ！！！!注意看完这一章节所有内容后再编写程序！！！！
> 
> ---

### 申请一块内存

我们一般使用两种方法申请内存

```c
//需要包含 stdlib.h
---这只是个例子，不要实际上写这两句，因为没有分配指针会无法释放内存造成内存泄漏---
malloc(<申请的空间大小>);
calloc(<分配的对象数量>, <每个对象的大小>);
//例如
malloc(sizeof(int) * 5);
calloc(5, sizeof(int));
```

这两种方法的区别在于

`malloc` 一般用于单个变量的申请，并且不会对内存初始化

多个也不是不行，但是需要手动计算内存大小，还是用 `calloc` 更好

`calloc` 一般用于数组的申请，并且会把空间初始化为 `0` （注意是内存上的 `0`）

### 访问分配的内存

分配了内存以后，我们需要一种方法来访问和操作它

这个时候你应该知道了，我们需要使用指针

`malloc` 和 `calloc` 是有返回值的

如果内存分配成功，他会返回一个 `void*` 类型即无类型指针

如果没有成功，则会返回 `NULL` 

```c
int* p = (int*)malloc(sizeof(int));
//一定要加入指针判断，操作空指针会导致未定义行为
if (p == NULL) {
    printf("memory allocation failed!");
    return 0;
}
*p = 10;
printf("%d", *p);
```

我们首先申请了一块 `int` 大小的内存，并且把指向这块内存起始地址的指针赋给了 `p`

> 注意这里需要显式的类型转换，转换为 `int` 类型的指针

然后我们 **必须** 判断指针是否是空的，不要操作空指针！

之后按照指针的操作来操作内存就行了

### 释放分配的内存

在我们使用完内存后，必须在程序结束之前释放分配的内存

如果没有释放内存，系统就无法使用这块内存，造成内存泄漏

> 小知识：360加速球加速的其中一步就是寻找泄漏的内存释放掉

我们可以使用下面的方法释放内存

```c
int* p = (int*)malloc(sizeof(int));
//一定要加入指针判断，操作空指针会导致未定义行为
if (p == NULL) {
    printf("memory allocation failed!");
    return 0;
}
*p = 10;
printf("%d", *p);
free(p); //在这里释放内存
```

### 重置指针

当我们释放内存之后，指针仍然指向这块内存指向的地址

这种指针叫做 **悬空指针** ，产生这种指针行为叫做 **指针空挂**

使用一个悬空的指针会导致未定义行为，甚至导致系统崩溃

所以我们在最后需要重置指针

```c
int* p = (int*)malloc(sizeof(int));
//一定要加入指针判断，操作空指针会导致未定义行为
if (p == NULL) {
    printf("memory allocation failed!");
    return 0;
}
*p = 10;
printf("%d", *p);
free(p);
p = nullptr; //在这里重置指针
```

通过把指针赋值为 `nullptr` 防止指针悬空

但是也不要使用空指针

注意如果一个指针指向的是一块动态内存的起始地址，不要改变它的地址

这可能导致释放内存或者重分配内存时出现意料之外的问题

使用指针算数来访问相应的内存

> 就是说不要使用 `p++,p--,p+=,p-=` 等会让指针偏移的方法
> 
> 而是使用 `*(p + i)` 这种不会改变指针本身地址方式

### 重分配内存

有时，我们需要动态调节内存的大小（通常是不够用了，于是扩大）

但是我们又不想丢掉原来的数据

这时候可以使用 `realloc` 方法

它会重新分配一块内存的大小

- 如果重新申请的内存更小，那么多出的部分数据会直接丢失，然后返回原来的地址

- 如果申请的内存更大，并且这块内存后面有足够的空间，那么它会直接扩充大小（注意不会初始化），然后返回原来的地址

- 如果申请的内存更大，但是这块内存之后没有足够大的连续空间，那么他会直接申请一块新的内存，并且把原来内存的数据迁移过去，然后自动释放旧的内存块，并且返回新内存的起始地址

- 如果申请失败，返回 `NULL` 

下面是使用的例子

```c
int* p = (int*)calloc(10, sizeof(int));

//一定要加入指针判断，操作空指针会导致未定义行为
if (p == NULL) {
    printf("memory allocation failed!");
    return 0;
}

p[0] = 10;
printf("%p -> %d\n", p, p[0]);
//在这里重分配内存
int* temp = (int*)realloc(p, sizeof(int) * 10000);
//检查申请结果
if (temp == NULL) {
    printf("memory allocation failed!");
    free(p); //如果要退出记得先释放之前的内存
    p = nullptr;
    return 0;
}
p = temp;
temp = nullptr; //及时重置指针

printf("%p -> %d\n", p, p[0]);

free(p);
p = nullptr; //在这里重置指针
```

> 可以发现，当重分配内存变小的时候，地址不变
> 
> 如果扩大内存，扩大之后大小差异明显，一般地址会改变

### 内存操作安全准则

- **初始化变量**
  
  - 在使用变量前记得初始化，调用未初始化的变量会导致不可预测的结果

- **检查数组边界**
  
  - 在调用数组时仔细检查数组边界，不要越界

- 使用标准库函数时注意缓冲区大小
  
  - 在使用 `strcpy` `strcat` 这类函数时注意缓冲区大小是否足够

- **动态内存管理**
  
  - 首先一定要检查内存是否分配成功
  
  - 及时释放不需要的内存，但是不要多次释放同一块内存
  
  - 不要释放没有分配给你的内存
  
  - 避免内存泄漏，即忘记释放内存就结束了程序

- **指针使用**
  
  - 确保你明确的知道指针指向什么地方
  
  - 你必须明确知道指针操作的是什么
  
  - 不要使用未初始化的指针
  
  - 不要使用已经释放的指针
  
  - 保证指针时刻指向一个有效的内存地址
  
  - 在适当的时候把指针重置为 `nullptr` ，防止指针空挂
  
  - 如果一个指针指向内存的起始地址，不要改变指针的地址，而是使用指针算术访问

> 确保你已经熟记了上面的安全准则，那么你就可以开始内存操作了

## 结语

就写到这里了，其他的可以自己上网了解

希望这个文档能对你的编程学习有所帮助

HaiMFeng

2024.11.28

[GitHub@Hai-M-Feng](https://github.com/Hai-M-Feng)
